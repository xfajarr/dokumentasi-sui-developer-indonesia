export const BACKGROUND_CODE = `
module hero::example; use sui::balance::{Self, Balance}; use sui::coin::{Self, Coin}; use sui::event; use sui::sui::SUI; public struct Boar has key, store { id: UID, game_id: ID, health: u64, experience: u64, sword: Option<Sword>, } public struct Sword has key, store { id: UID, game_id: ID, magic: u64, strength: u64, } public struct Potion has key, store { id: UID, game_id: ID, potency: u64, } public struct Boar has key, store { id: UID, game_id: ID, health: u64, strength: u64, } public struct Game has key { id: UID, payments: Balance<SUI>, } public struct Admin has key { id: UID, game_id: ID, boars_created: u64, potions_created: u64 } public struct BoarSlainEvent has copy, drop { slayer_address: address, boar: ID, hero: ID, game_id: ID, } const MAX_HP: u64 = 100; const MAX_MAGIC: u64 = 10; const MIN_SWORD_COST: u64 = 100; const EWrongGame: u64 = 0; const EBoarWon: u64 = 1; const EHeroTired: u64 = 2; const ENotAdmin: u64 = 3; const EInsufficientFunds: u64 = 4; const EAlreadyEquipped: u64 = 5; const ENoSword: u64 = 6; const ENotEquipped: u64 = 7; public fun new_sword(game: &mut Game, payment: Coin<SUI>, ctx: &mut TxContext): Sword { let value = payment.value(); assert!(value >= MIN_SWORD_COST, EInsufficientFunds); coin::put(&mut game.payments, payment); let magic = (value - MIN_SWORD_COST) / MIN_SWORD_COST; Sword { id: object::new(ctx), magic: magic.min(MAX_MAGIC), strength: 1, game_id: object::id(game) } } public fun new_hero(sword: Sword, ctx: &mut TxContext): Hero { Hero { id: object::new(ctx), game_id: sword.game_id, health: 100, experience: 0, sword: option::some(sword) } } public fun new_game(ctx: &mut TxContext) { let game = Game { id: object::new(ctx), payments: balance::zero() };transfer::share_object(game); let admin = Admin { id: object::new(ctx), game_id: object::id(&game), boars_created: 0, potions_created: 0, }; transfer::transfer(admin, tx_context::sender(ctx)); } public fun new_potion(game: &Game, admin: &mut Admin, potency: u64, ctx: &mut TxContext): Potion { admin.potions_created = admin.potions_created + 1; Potion { id: object::new(ctx), potency, game_id: admin.game_id } } public fun slay_boar(game: &mut Game, hero: &mut Hero, boar: Boar, ctx: &mut TxContext) { let Boar { id: boar_id, game_id: boar_game_id, .. } = boar; assert!(hero.game_id == game.id, EWrongGame); assert!(boar_game_id == game.id, EWrongGame); let hero_strength = hero_strength(hero); let boar_health = boar.health - hero_strength; }; assert!(hero.health >= boar_strength, EBoarWon); hero.health = hero.health - boar_strength; hero.experience = hero.experience + experience; if (hero.sword.is_some()) { hero.sword.borrow_mut().level_up_sword(); } event::emit(BoarSlainEvent { slayer_address: ctx.sender(), hero: object::id(hero), boar: boar_id, game_id: game.id, }); } public fun destroy_sword(sword: Sword) { let Sword { id, .. } = sword; object::delete(id); } public fun hero_strength(hero: &Hero): u64 { if (hero.sword.is_some()) { hero.sword.borrow().strength() + hero.experience } else { 0 } + hero.experience * 2 } public fun level_up_sword(sword: &mut Sword, amount: u64) { sword.strength = sword.strength + amount } public fun sword_strength(sword: &Sword): u64 { sword.strength } public fun heal(hero: &mut Hero, potion: Potion) { let Potion { id, potency, game_id } = potion; object::delete(id); assert!(hero.game_id == game_id, EWrongGame); hero.health = (hero.health + potency).min(MAX_HP) } public fun equip(hero: &mut Hero, sword: Sword) { assert!(hero.sword.is_none(), EAlreadyEquipped); assert!(hero.game_id == sword.game_id, EWrongGame); hero.sword.fill(sword); } public fun unequip(hero: &mut Hero): Sword { assert!(hero.sword.is_some(), ENotEquipped); hero.sword.extract()} module hero::example; use sui::balance::{Self, Balance}; use sui::coin::{Self, Coin}; use sui::event; use sui::sui::SUI; public struct Boar has key, store { id: UID, game_id: ID, health: u64, experience: u64, sword: Option<Sword>, } public struct Sword has key, store { id: UID, game_id: ID, magic: u64, strength: u64, } public struct Potion has key, store { id: UID, game_id: ID, potency: u64, } public struct Boar has key, store { id: UID, game_id: ID, health: u64, strength: u64, } public struct Game has key { id: UID, payments: Balance<SUI>, } public struct Admin has key { id: UID, game_id: ID, boars_created: u64, potions_created: u64 } public struct BoarSlainEvent has copy, drop { slayer_address: address, boar: ID, hero: ID, game_id: ID, } const MAX_HP: u64 = 100; const MAX_MAGIC: u64 = 10; const MIN_SWORD_COST: u64 = 100; const EWrongGame: u64 = 0; const EBoarWon: u64 = 1; const EHeroTired: u64 = 2; const ENotAdmin: u64 = 3; const EInsufficientFunds: u64 = 4; const EAlreadyEquipped: u64 = 5; const ENoSword: u64 = 6; const ENotEquipped: u64 = 7; public fun new_sword(game: &mut Game, payment: Coin<SUI>, ctx: &mut TxContext): Sword { let value = payment.value(); assert!(value >= MIN_SWORD_COST, EInsufficientFunds); coin::put(&mut game.payments, payment); let magic = (value - MIN_SWORD_COST) / MIN_SWORD_COST; Sword { id: object::new(ctx), magic: magic.min(MAX_MAGIC), strength: 1, game_id: object::id(game) } } public fun new_hero(sword: Sword, ctx: &mut TxContext): Hero { Hero { id: object::new(ctx), game_id: sword.game_id, health: 100, experience: 0, sword: option::some(sword) } } public fun new_game(ctx: &mut TxContext) { let game = Game { id: object::new(ctx), payments: balance::zero() };transfer::share_object(game); let admin = Admin { id: object::new(ctx), game_id: object::id(&game), boars_created: 0, potions_created: 0, }; transfer::transfer(admin, tx_context::sender(ctx)); } public fun new_potion(game: &Game, admin: &mut Admin, potency: u64, ctx: &mut TxContext): Potion { admin.potions_created = admin.potions_created + 1; Potion { id: object::new(ctx), potency, game_id: admin.game_id } } public fun slay_boar(game: &mut Game, hero: &mut Hero, boar: Boar, ctx: &mut TxContext) { let Boar { id: boar_id, game_id: boar_game_id, .. } = boar; assert!(hero.game_id == game.id, EWrongGame); assert!(boar_game_id == game.id, EWrongGame); let hero_strength = hero_strength(hero); let boar_health = boar.health - hero_strength; }; assert!(hero.health >= boar_strength, EBoarWon); hero.health = hero.health - boar_strength; hero.experience = hero.experience + experience; if (hero.sword.is_some()) { hero.sword.borrow_mut().level_up_sword(); } event::emit(BoarSlainEvent { slayer_address: ctx.sender(), hero: object::id(hero), boar: boar_id, game_id: game.id, }); } public fun destroy_sword(sword: Sword) { let Sword { id, .. } = sword; object::delete(id); } public fun hero_strength(hero: &Hero): u64 { if (hero.sword.is_some()) { hero.sword.borrow().strength() + hero.experience } else { 0 } + hero.experience * 2 } public fun level_up_sword(sword: &mut Sword, amount: u64) { sword.strength = sword.strength + amount } public fun sword_strength(sword: &Sword): u64 { sword.strength } public fun heal(hero: &mut Hero, potion: Potion) { let Potion { id, potency, game_id } = potion; object::delete(id); assert!(hero.game_id == game_id, EWrongGame); hero.health = (hero.health + potency).min(MAX_HP) } public fun equip(hero: &mut Hero, sword: Sword) { assert!(hero.sword.is_none(), EAlreadyEquipped); assert!(hero.game_id == sword.game_id, EWrongGame); hero.sword.fill(sword); } public fun unequip(hero: &mut Hero): Sword { assert!(hero.sword.is_some(), ENotEquipped); hero.sword.extract() }
`;
